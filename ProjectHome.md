The eco stack provides a fast and concise LSL library that simplifies event handling, prim animations, and avatar interactions for rapid virtual pet development. This full featured LSL framework is lightweight and built with progressive enhancement, and has a flexible, easily scale-able design for adding features to physical and non-physical animals, pets, and other creations.

Remote access to all of your creations! Just add the scripts to your objects and define your species on your account page. Skins, animations, settings, and all functionality can be created, modified, and available immediately across the grid.

Customization is very important with this project. All elements of the core functionality can be ammended, tuned, and even replaced with almost no overhead. Eco extensions give you the ability to create your own methods using native LSL functions which can be triggered during event flow and contain real time values from the enormous expression library. A web API has also been created to give web developers the ability to integrate their breeds on their own site and apps. All information available on the user's account and to the inworld objects is formatted into JSON results for easy web integration. This data feed is kept secure and where an API key is available to all Second Life residents for their own account after validation.

Actions define what your breeds do, how they behave, and when various events are triggered. An extensive library of methods have been created to give creators a vast resource of feature-rich functionality that help to make their breeds truely unique. An endless supply of action objects (home, food, toys, accessories, etc) can easily be created, each with their own restrictions and limitations.

Event flow is created by binding events to user-defined methods and conditions. Binding an event allows you to define the conditions for it to be raised. These events can later be unbound which is useful for creating on/off states for your events. Conditions can be applied within the event to further direct the event flow and create an even more rich experience. For example an owner only touch which raises an event, and functionality within is determined based on the owner's distance, time of day, or another arbitrary environmental condition. This is accomplished in one line to define the event: bind(touch,owner,action) and another within the event to direct the flow: filter(%ownerdist%>10,callback) where the filter diverts event flow to the callback event if the owner is close, or otherwise continues traversing subsequent methods in the event. Events can be created, filtered, forked, toggled, paused, and enabled/disabled entirely.

Genetics are arrays of unique information which defines an individual which include skins, traits, and other values passed on through breeding. Rules for natural and selective breeding aide in the creation of a unique lineage with every generation. These rules cover partner selection, breeding and pregnancy behaviors, and support for a variety of orientations: asexual, same-sex, monogamous, polygamous with morality rules that determine the loyalty and capacity of each breed. Advanced options include timers and limits which handle timeout queues for lost/missing partners, pregnancy time, min/max breeding age and litter sizes, number of births and odds filters that help detrmine genders, failed births, and rare litter sizes.

Communications are very easy to configure. Progressive menus, text-inputs, hover text, and local/private chat are defined in a single line and internally converted, replacing recognized expressions with real time breed information. Local or hidden chat messages can be interpreted and searched for keywords or phrases containing commands or other information. This allows the end-user to type a natural sentence like "hey jerry, come get your food" where "jerry" recognizes his name, and knows to "come" to the owners position but if "food" is mentioned, perhaps his configurations detmines he doesnt come if he's not hungry, and instead says "No Thanks!". Menus are also easy to set up, where button labels can be toggled, removed, or replaced and all input assigned to it's own callback. All user input is then converted to a recognized chat expression which can be used in a variety of built in methods. This goes beyond stats and chat messages, to an intuitive chat processor that can be useful in creating games or other advanced simulations.

Growth is a built-in event which is defined by the number of potential growth stages, the rate of growth, the scale or percentage of growth that occurs each cycle, as well as the odds of stunted growth. All prims are scaled and repositioned based on it's overall growth which is also applied to prim animations to ensure growth and prim manipulation is seamless and fluid. This formula is also used when rebuilding existing breeds to create the exact copy of the breed at it's last know size. Any accessories (hats, glasses, effects, etc) applied to the breeds will be scaled with the breed and also rescaled during regeneration (rebuilding).

Hunger is a core trait with a range from 0 to 100 coupled to a native event which is dependent on food sources. Food sources can be provided with different levels and qualities as well as limitations to control the number and type of breeds it can feed. The food can be replenished or spoil, and special traits earned from them. The food sources themselves can be a breed object of a different species, such as a plant or other animal. Multiple sources can be provided and food can be "farmed" or produced as a trade item that maintains it's value until consumed by breed objects. The rate of hunger, decline, and starvation can be manipulated based on environmental conditions so the scope of the appetite is not merely limited to an initial configuration. The hunger value and event is a built in example of what can be produced with bind() filter() and prop() methods, thus additional traits can be created, defined, and even passed on to offspring as per the rules used to create the values.

Movement is the most visually evident aspect of a scripted object in second life. The performance and behavior of a physical or non-physical object is what seperates a lifeless drone from an intelligent and interactive creature. The ability to navigate obsticles and be aware of enviromental hazards is vital in safe and fluid movement. These flags can be set seperately and a callback can be defined if a flag is raised. The future trend of second life is an environment where the avatar is no longer an observer of a predictable 3d world, but a participant in an interactive world where AI beings perform tasks or otherwise co-exist with real users much like the AI seen in most video games. To accomplish this, an easy to define move() method was created with twelve (12) built-in physical AND smooth non-physical movement behaviors encompass ground, flighted, and swimming motions. Movement behaviors can be used together or individually to allow you to have animals and objects that behave naturally based on environmental or toggled conditions. These behaviors can be highly tuned or even replaced to ensure each creator has the ability to acheive their desired results. Animations can be synced with movement and dynamic values can be used to set destinations and speed. The move() method allows for multi-region travel as well instant warping within a region. Unlimit your breed's potential by binding unique traits to movement values to create noticeable attributes like stamina or agility.

Prim animations are what give your breed personality and can be created for breeds with specific skins, trait levels, age bracket, gender, or other conditions. This opens up the door to creating states of emotion, physical fatigue, and overall condition. The prim methods used to create animations cover all common prim manipulations and can be defined with a repeat, delay, and number of frames in the sequence. But prim methods are not just for animation sequences. These methods also allow you to create accessories (hats, glasses, effects, etc) and other physical attributes (wounds/scars, horns/antlers, growing hair) which can be applied during event flow or as an add-on that can be distributed seperately. Since animations are created and stored remotely, additional animations can be created and implemented later, thus allowing for easy post-release development. This also means sequences can be tweaked or improved and the results will be effective immediately in all breeds accross the grid.

Skins are created useing the same tools available for prim animations, thus entire linksets can be altered to create a truely unique skinset. Skins are generated based on the conditions defined for each skin, requested and applied upon creation, then saved and later passed on to offspring. Additional skinsets can be saved to create dormant skins that may require conditions to be met or are otherwise set by chance. Rare, unlockable, or limited edition skins can be created, as well as skin-specific animations that are useful for maintaining compatibility with skins that have different sculpts/mesh/prim shapes or position/rotation offsets. The lineage is preserved throughout generations and encourages the selective breeding of objects with rare, unlockable, or limited edition skins. Separate categories can be defined where one skin is applied from each category creating a mix and match of physical features, or simply create pure breeds with an array of complete skinsets.

Rebuilding lost or missing breeds is not only vital for maintaining the value of an individual breed, but incredibly useful for simulations that require the breed to disappear, such as to go sleep in a home or 'venture into the wild', and be able to seamlessly return with the same unique values, skins, accessories, growth, levels, and traits as before it disappeared. This is also useful for updating your customers if/when changes are made, such as adding extensions or changed primsets.

Statistics for all breeds and species are available in JSON format for each user. Record management is made easy with sortable tables and data filters to help you navigate potentially thousands of breed records. Visualizations aide in creating a balanced eco system and since the data feeds are open to individual creators via the API, it's possible for anyone to plug their stats into their own vizualization code. The future of the eco project will includes bringing powerful UI widgets to the account pages for dynamic eco system management.

Co-op development with partners and friends by assigning "authorized user" roles to verified avatars. This authorization allows the alternate user(s) to make changes to your species under their own account, and this can be granted/revoked at any time.

Help & Support is available 7 days a week to ensure that your development process is moving smoothly. Contact Dev Khaos inworld or submit a ticket for a quick response!